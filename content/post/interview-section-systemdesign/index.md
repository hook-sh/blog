---
title: Вопросы и ответы по системному дизайну для собеседования
slug: interview-section-systemdesign
date: 2022-05-02T06:17:19Z
expirydate: 2026-08-03T06:17:19Z
draft: true # uncomment this!
image: cover.png
categories: [interview]
tags: [interview, design]
---

_WIP_

<!--more-->

{{< table_of_contents >}}

## Что такое RESTful API?

**REST** означает **RE**presentational **S**tate **T**ransfer ("передача состояния представления") - это популярный архитектурный подход для создания API в современном мире. Его предшественником можно считать SOAP (Simple Object Access Protocol).

Этот термин первоначально ввёл Рой Филдинг (Roy Fielding), который также был одним из создателей протокола HTTP. По большому счёту, REST - это **стиль**, а не стандарт.

REST фокусируется на **ресурсах** (разных типах информации), доступ к которым осуществляется через URL. Для управления ими используются различные HTTP-методы (а не суффиксы URN) такие, как `GET` (чтение), `POST` (создание), `PUT` (обновление) и `DELETE` (удаление).

REST API **не сохраняют свои состояния** и могут кэшироваться. Отсутствие состояния означает, что каждый раз, когда вы обращаетесь к ресурсу через конечную точку, API предоставляет один и тот же ответ. Он не запоминает ваш последний запрос и не учитывает его при предоставлении нового ответа. Другими словами, нет ранее запомненных состояний, которые API учитывает при каждом запросе.

Для описания REST API часто используется [OpenAPI](https://www.openapis.org/) (является стандартом де-факто) и [SwaggerUI](https://github.com/swagger-api/swagger-ui) для её отображения.

> Что можно почитать:
> - [What is REST](https://restfulapi.net/)

## Чем RabbitMQ отличается от Apache Kafka?

[**RabbitMQ**](https://github.com/rabbitmq) (написан на Erlang) - это распределенная система управления очередью сообщений. Распределенная, поскольку обычно работает как кластер узлов, где очереди распределяются по узлам и, опционально, реплицируются в целях устойчивости к ошибкам и высокой доступности. Так же RabbitMQ умеет в гибкую **маршрутизацию сообщений**.

Общая схема работы с RabbitMQ выглядит как:

- Паблишеры (`publishers`) отправляют сообщения на `exchange`
- `exchange` отправляют сообщения в очереди и в другие `exchange`
- RabbitMQ отправляет подтверждения паблишерам при получении сообщения
- Получатели (`consumers`) поддерживают постоянные TCP-соединения с RabbitMQ и объявляют, какую очередь(-и) они получают
- RabbitMQ проталкивает (`push`) сообщения получателям
- Получатели отправляют подтверждения успеха/ошибки
- После успешного получения, сообщения удаляются из очередей

> Есть возможность создавать exchange c недоставленными сообщениями (`dead letter exchange`), т.е. когда сообщения из очереди не могут быть получены по тем или иным причинам, их можно откладывать и обрабатывать отдельно.

RabbitMQ дает гарантии "одноразовой доставки" и "хотя бы одной доставки", но не "ровно одной доставки".

[**Kafka**](https://github.com/apache/kafka) (написана на Java) - распределенный реплицированный журнал фиксации изменений (commit log), и у неё **нет** концепции очередей. **Сообщения хранятся** в сегментированных, append-only **журналах**, которые называются топиками.

Вместо того чтобы помещать сообщения в очередь FIFO и отслеживать статус этого сообщения в очереди, как это делает RabbitMQ, Kafka просто добавляет его в журнал, и на этом все.

Сообщение остается, вне зависимости от того, будет ли оно получено один или несколько раз. Удаляется оно в соответствии с политикой удерживания данных (`retention policy`, также называемый `window time period`). Каждый получатель отслеживает, где информация находится в журнале - имеется указатель на последнее полученное сообщение и этот указатель называется адресом смещения.

С Kafka мы можем вернуться "в прошлое" (сместив указатель назад на нужный отрезок), и перечитать сообщения заново, без необходимости их заново публиковать (как это было бы с RabbitMQ).

Kafka не поддерживает конкурирующих получателей в **одной партиции** (**партиция** - это составляющая часть топика; представляет собой отдельный файл, в котором гарантируется очередность сообщений), блок параллельности Kafka — это **сама партиция**.

Так же между RabbitMQ и Kafka можно выделить следующие отличия:

- RabbitMQ использует модель проталкивания (`push`), в то время как Kafka использует модель вытягивания (`pull`), где получатели запрашивают партии сообщений с заданного относительного смещения
- Масштабирование и поддержание порядка сообщений с Kafka намного проще

> Что можно почитать:
> - [RabbitMQ против Kafka: два разных подхода к обмену сообщениями](https://habr.com/ru/company/itsumma/blog/416629/)

## Что такое гексагональная архитектура?

_WIP_

https://habr.com/ru/post/651799/

## Кейс по system design

_WIP_

## Какую архитектуру API бы выбрал для кейса?

_WIP_

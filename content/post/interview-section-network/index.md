---
title: Вопросы и ответы для интервью - сети
slug: interview-section-network
#description: Interview section network
date: 2022-02-14T12:37:08Z
expirydate: 2027-08-15T12:37:08Z
#draft: true
image: cover.jpg
categories: [dev]
toc: true
tags: [interview, network]
---

Часто на интервью задают вопросы связанные не только с основным/дополнительным ЯП или СУБД, но и с тем, как приложения взаимодействуют между собой используя сетевую коммуникацию. Для понимания того, как эти шестерёнки вращаются и что нужно иметь в виду отвечая на вопросы из этой серии и была написана эта заметка.

<!--more-->

{{< table_of_contents >}}

## Что происходит, когда я в браузере перехожу на `example.com`?

_WIP_

## Что такое TCP/IP?

Изначально **стек протоколов TCP/IP** разработан в 1972 году на основе Network Control Protocol, но только спустя 4 года создана передача данных с применением протокола TCP. К концу 80-х было выделено две отдельные функции – TCP и IP. И уже к 1983 году удалось полностью перейти на современный протокол, что и считается отправной точкой развития Интернета.

Стек модели TCP/IP контролирует взаимодействие различных уровней системы (стек делится на отдельные уровни, каждый из которых направлен на решение определенной задачи). Ключевыми в нем являются сами протоколы, которые встраиваются друг в друга (работают одновременно, без конфликтов, сбоев и незавершенных операций) и обеспечивают передачу данных.

![Открытая сетевая модель OSI (Open Systems Interconnection model)](osi.png)

**IP** (Internet Protocol) - маршрутизируемый протокол **сетевого уровня** модели стека протоколов TCP/IP, нужен для логической адресации устройств в компьютерной сети или сети передачи данных. Ключевые понятия о протоколе IP:

- Каждый узел на сетевом уровне в модели TCP/IP должен иметь **IP-адрес**, который состоит из 4 байт (`254.254.254.254`)
- Минимальной единицей измерения данных здесь является **IP-пакет** (который чаще всего инкапсулируется в Ethernet кадр)
- При доставке IP-пакета возможна его **фрагментация** (дробление) на более мелкие (получатель должен будет его собрать обратно). Так же возможен и запрет на фрагментацию (отправителю будет отправлен ICMP-сообщение об ошибке)
- Функция IP протокола заключается в том, чтобы **доставить пакет из точки А в точку Б** через множество промежуточных сетей (при этом IP-пакеты при передаче данных могут быть изменены, потеряны, повреждены, пакеты могут прийти получателю не в той последовательности, в которой они были отправлены - обо всем этом протокол IP не заботится, его задачей является организовать маршрут)
- Протокол использует передачу данных **без установки соединения**

Размер заголовка IP-пакета составляет от 20 (обычный заголовок без дополнительных опций) до 60 байт.

**TCP** (Transmission Control Protocol) - протокол **транспортного уровня**, управляющий передачей данных. Фактически, если IP протокол связывает между собой машины в сети, то **TCP связывает конкретные приложения используя порты** _(которых одновременно на машине может быть до 65535, т.к. номер порта занимает 2 байта)_. Ключевые характеристики:

- **Требует установки соединения** (для этого сервер делает passive open - ждёт входящие запросы, а клиент active open - отправляет серверу `SYN`, на что сервер должен ответить `ACK` + `SYN`, клиент в ответ на это должен ответить `ACK`, и после этого соединение считается установленным)
- Нумерует пакеты, посылает подтверждения о получении данных (`ACK`) и запрашивает повторную передачу, если данные не получены или искажены (или истёк таймаут для ответа)
- Любое установленное TCP-соединение симметрично, и пакеты с данными по нему всегда идут в обе стороны (двунаправленная взаимосвязь)
- Когда один из узлов решает, что пора заканчивать соединение, он посылает специальный пакет `FIN`, после этого узлы прощаются и разрывают соединение
- Использование принципа "скользящего окна" для увеличения скорости передачи (`ACK` не каждого сообщения, а определенной "пачки"; причём размер окна может меняться динамически)

{{< youtube Y1g6RabHBoA >}}

> Что можно почитать:
> - [Wiki: IP](https://ru.wikipedia.org/wiki/IP)
> - [IP-пакет в протоколе IPv4. Структура, заголовок и поля в IP-пакете](https://zametkinapolyah.ru/kompyuternye-seti/4-3-struktura-i-zagolovok-ip-paketa-v-protokole-ipv4.html)

## Какие бывают версии HTTP?

HTTP (HyperText Transfer Protocol) - это клиент-серверный протокол прикладного уровня, реализованный поверх протокола TCP/IP _(третья версия протокола работает используя UDP)_. Сам HTTP зависит от протокола TCP/IP (UDP), позволяющего посылать и отправлять запросы между клиентом и сервером. По умолчанию используется 80 порт TCP, но могут использоваться и другие (HTTPS, например, использует 443 порт).

Выполнить простейший HTTP запрос можно с помощью `telnet`:

```bash
$ telnet google.com 80
Trying 142.251.1.113...
Connected to google.com.
Escape character is '^]'.
GET /robots.txt HTTP/1.1
Host: google.com

# просто 2 пустые строки (2 раза нажми enter)
HTTP/1.1 301 Moved Permanently
(headers)
(content)
```

### `HTTP/0.9`

Появился в конце 1990 года (разработан Тимом Бернерсом-Ли) и был экстремально простым - запрос состоял из одной строки и умел только метод `GET` (`GET /mypage.html`), а ответ в свою очередь только контент ответа (обычно HTML; без заголовков) и даже без кода ответа.

```http request
GET /mypage.html

<HTML>
A very simple HTML page
</HTML>
```

### `HTTP/1.0`

[Спецификация (RFC 1945)](https://datatracker.ietf.org/doc/html/rfc1945) была опубликована в ноябре 1996 года. Информация о версии протокола теперь отправляется с каждым запросом (`GET /mypage.html HTTP/1.0`). Код ответа отправляется в самом начале ответа (`200 OK`). Добавлена **поддержка заголовков** (как запросов, так и ответов) для передачи мета-информации. К методу `GET` добавились `HEAD`, `POST`, `PUT`, `DELETE`, `LINK`, `UNLINK`. Кроме того, с помощью заголовка `Content-Type` стало возможным передавать разные типы контента:

```http request
GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

200 OK
Date: Tue, 15 Nov 1996 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html
<HTML>
A page with an image <IMG SRC="/myimage.gif">
</HTML>
```

Для каждого запроса и ответа между клиентом и сервером создаётся новое TCP-соединение (пожалуй, главный недостаток, поскольку каждое новое TCP-соединение требует "тройного рукопожатия", за которым следует [медленный старт](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B4%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D1%81%D1%82%D0%B0%D1%80%D1%82)).

### `HTTP/1.1`

Появился всего через несколько месяцев после версии `1.1` (в январе 1997 года, [RFC 2068](https://datatracker.ietf.org/doc/html/rfc2068), и по 2014 год выходили "дополнительные" RFC для этой версии протокола), и изменения были следующие:

- Соединение могло быть пере-использовано (не требуется постоянно поднимать новое TCP соединение для запроса, управляется с помощью заголовка `Connection: close` или `Connection: keep-alive`)
- Добавлена поддержка заголовка [`Host`][http-header-host] содержащего имя домена, для которого предназначен запрос (опционально и номер порта), что позволило держать на одном IP множество доменов (сайтов)
- Добавлены методы `OPTIONS`, `TRACE`, `PATCH`, `CONNECT` (последний добавлен в 2014 году)
- Добавлено согласование контента (включающее в себя язык [`Accept-Language: <lang>`][http-header-accept-language], кодировку [`Accept-Encoding: <directives>`][http-header-accept-encoding], тип данных - [`Accept: <mime_type>/*`][http-header-accept] и другие)
- Добавлены заголовки управления кэшированием контента ([`Cache-Control: <directives>`][http-header-cache-control], [`Expires: <http-date>`][http-header-expires], [`Last-Modified: <when>`][http-header-last-modified], [`ETag: <hash>`][http-header-etag] и другие)
- Добавлена возможность доставки контента частями _(или чанками, chunks)_, управляется заголовком [`Transfer-Encoding: <directives>`][http-header-transfer-encoding] и другими (в этом случае нет необходимости заранее знать точный размер всего тела HTTP-сообщения); HTTP/2 не поддерживает эту фичу, но имеет другие, более эффективные механизмы для потовой передачи данных
- Добавлена конвейерная обработка, позволяющая передавать сразу несколько запросов в одном соединении, не ожидая соответствующих ответов (но нужно помнить, что сервер должен отдавать ответы в строго той же последовательности, как получались запросы, и один затормозивший запрос тормозит все последующие в "пачке"); в HTTP/2 эта фича была заменена на мульти-плексирование
- Добавлена возможность использования заголовка [`Upgrade: <protocol>[/<version>]`][http-header-upgrade] для переключения на другой протокол, например `HTTP/2.0` или `WebSockets`, и эта функциональность присуща только версии `HTTP/1.1`

```http request
GET /en-US/docs/Glossary/Simple_header HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Wed, 20 Jul 2016 10:55:30 GMT
Etag: "547fa7e369ef56031dd3bff2ace9fc0832eb251a"
Keep-Alive: timeout=5, max=1000
Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT
Server: Apache
Transfer-Encoding: chunked
Vary: Cookie, Accept-Encoding

(content)
```

### `HTTP/2`

[Спецификация (RFC 7540)](https://datatracker.ietf.org/doc/html/rfc7540) была опубликована в мае 2015 года, основан на протоколе [SPDY][spdy] _(a.k.a "speedy", разработан Google в 2012 году, поддержка которого прекратилась в феврале 2015 в пользу `HTTP/2`; при его использовании время загрузки страниц уменьшалось на ~36%)_. В 2021 году порядка **50,2%** самых популярных сайтов поддерживают этот протокол.

В отличии от `HTTP/1.1`:

- Протокол стал **бинарным** (сообщения быстрее разбираются автоматически, но неудобны для чтения человеком), основные составляющие `HTTP/2` — фреймы (Frames) и потоки (Streams):
  - HTTP-сообщения состоят из одного или более фреймов (`HEADERS` для мета-данных, `DATA` для данных, `RST_STREAM` для прерывания потоков - при этом соединение останется открытым что позволяет работать остальным потокам, `SETTINGS`, `PRIORITY` и [другие](https://datatracker.ietf.org/doc/html/rfc7540#section-6))
  - Каждый запрос и ответ HTTP/2 получает **уникальный ID** потока и разделяется на фреймы
  - Фреймы представляют собой просто бинарные части данных; коллекция фреймов называется потоком (Stream)
  - Каждый фрейм содержит ID потока, показывающий, к какому потоку он принадлежит; а также каждый фрейм содержит общий заголовок (идентификатор потока уникален; каждый клиентский запрос использует **не**чётные id, а ответ от сервера — чётные)
- Добавлено **мультиплексирование** - передача нескольких асинхронных HTTP-запросов по одному TCP-соединению
  - Ответ сервера не имеет порядка, и клиент использует ID потока, чтобы понять, к какому потоку принадлежит тот или иной пакет
  - Клиенту не придётся простаивать, ожидая обработки длинного запроса, ведь во время ожидания могут обрабатываться остальные запросы
- Реализовано сжатие передаваемых заголовков (методом `HPACK`)
  - Клиент и сервер поддерживают единую таблицу заголовков
  - Повторяющиеся заголовки (например, `user-agent`) опускаются при повторных запросах и ссылаются на их позицию в таблице заголовков
  - Сами заголовки ничем не отличаются от `HTTP/1.1`, но добавились псевдо-заголовки вида `:method`, `:scheme`, `:host`, `:path`
- Появился Server Push - несколько ответов на один запрос
  - Сервер имеет право послать то содержимое, которое ещё не было запрошено клиентом, используя специальный фрейм `PUSH_PROMISE`
- Добавлена явная приоритизация запросов (используя фрейм `HEADERS` которым открывается поток, или в любое другое время используя фрейм `PRIORITY`)
- Повышена безопасность (хотя спецификация не требует шифрования для `HTTP/2`, оно всё равно станет обязательным по умолчанию, так как браузеры без шифрования не работают с этим протоколом)

Так же стоит знать, что мультиплексирование ведёт к проблеме доставки контента при ошибках на сетевом уровне. Представьте, что мы асинхронно выполняем 5 запросов к одному серверу. При использовании `HTTP/2` все эти запросы будут выполняться в рамках одного TCP-соединения, а значит, если один из сегментов любого запроса потеряется или придёт неверно, передача всех запросов и ответов остановится, пока не будет восстановлен потерявшийся сегмент (у этой проблемы есть и название - "head-of-line blocking"). Очевидно, что **чем хуже качество соединения, тем медленнее работает HTTP/2** (когда потерянные пакеты составляют всего **2%** от всех, `HTTP/1.1` в браузере показывает себя лучше, чем `HTTP/2` за счёт того, что открывает 6 соединений, а не одно).

### `HTTP/3`

Проектируется для решения проблем `HTTP/2` и сейчас проходит тестирование с опубликованной спецификацией. Новый протокол должен решать текущие проблемы скорости, надёжности и безопасности для широкого сектора устройств. `HTTP/3` строится на основе нового протокола [QUIC][quic], разрабатываемого в Google с 2012 года. Основные отличия от предшественника:

- Вместо TCP будет использоваться **UDP**
- QUIC сам обеспечивает мультплексирование, и потеря одного пакета повлияет только на имеющий к этому пакету поток, другие потоки в рамках соединения продолжат свою работу
- Заголовки запросов и ответов сжимаются `QPACK` вместо `HPACK`
- Для шифрования используется TLS 1.3 (эффективно использующийся в HTTPS) - оно включено в протокол
  - Это позволяет устанавливать соединение и обмениваться публичными ключами за одно рукопожатие, а также позволяет использовать хитрый механизм 0-RTT handshake и вообще избежать задержек при рукопожатии
  - Кроме того, теперь можно шифровать отдельные пакеты данных (это позволяет не ждать завершения приёма данных из стрима, а расшифровывать полученные пакеты независимо)
- Концепция лёгких стримов позволяет отвязать соединение от IP-адреса клиента (например, когда клиент переключается с одной Wi-Fi точки доступа на другую, изменяя свой IP - при использовании TCP происходит длительный процесс, в ходе которого существующие TCP-соединения отваливаются по таймауту; в случае с QUIC, клиент просто продолжает посылать серверу пакеты с нового IP со старым ID стрима)
- QUIC реализуется на уровне приложения, а не операционной системы (позволяет быстрее вносить изменения в протокол, т.к. чтобы получить обновление достаточно просто обновить библиотеку, а не ждать новую версию ОС)

Последние версии браузеров Chrome, Firefox, Edge, Opera и некоторые мобильные браузеры уже поддерживают работу по HTTP/3, но для работы должна быть и поддержка со стороны сервера. На данный момент `HTTP/3` активно используется в Google и Cloudflare.

По статистике на июль 2021 года только 20% вебсайтов доступны по `HTTP/3`. По отчетам Google через gQUIC страницы загружаются примерно на 5% быстрее, а в потоковом видео на 30% меньше подвисаний по сравнению с TCP.

К слабым сторонам протокола пока что можно отнести высокое потребление CPU, жадность (unfairness) к пропускной способности канала и более медленная передача небольших (до 10 кб) объектов. А так же неготовность интернета к полному переходу на UDP.

> Что можно почитать:
> - [Evolution of HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)
> - [Путь к HTTP/2](https://habr.com/ru/post/308846/)
> - [HTTP/3: прошлое, настоящее и будущее](https://ru.hexlet.io/blog/posts/http-3-proshloe-nastoyaschee-i-buduschee)
> - [Введение в HTTP/2](https://developers.google.com/web/fundamentals/performance/http2?hl=ru)

[http-header-host]:https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Host
[http-header-accept]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept
[http-header-accept-encoding]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding
[http-header-accept-language]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language
[http-header-cache-control]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
[http-header-expires]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires
[http-header-last-modified]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified
[http-header-etag]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag
[http-header-transfer-encoding]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding
[http-header-upgrade]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade
[spdy]:https://ru.wikipedia.org/wiki/SPDY
[quic]:https://ru.wikipedia.org/wiki/QUIC

## Как работает HTTPS?

_WIP_

## Что такое RESTful API?

_WIP_

## Что такое CORS?

_WIP_

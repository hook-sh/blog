---
title: Вопросы и ответы для интервью Golang разработчика
slug: go-interview-questions
#description: Go Interview Cheat
date: 2022-02-02T06:17:19Z
expirydate: 2026-08-03T06:17:19Z
#draft: true
image: cover.png
categories: [go]
tags: [golang, interview, coding]
---

Структурирование информации - очень полезный навык. И дабы привнести некоторый порядок в этап подготовки к интервью на должность Golang разработчика (и немножко техлида) решил записывать в этой заметке в формате FAQ те вопросы, которые я задавал, задавали мне или просто были мной найдены на просторах сети вместе с ответами на них. Стоит относиться к ним как к шпаргалке (если затупишь на реальном интервью - будет где подсмотреть) и просто набору тем, которым тебе стоит уделить внимание.

<!--more-->

## Расскажи о себе?

Чаще всего этот вопрос идёт первым и даёт возможность интервьюверу задать вопросы связанные с твоим резюме, познакомиться с тобой, попытаться понять твой характер для построения последующих вопросов. Следует иметь в виду, что интервьюверу не всегда удается подготовиться к интервью, или он банально не имеет перед глазами твоего резюме. Тут есть смысл ещё раз представиться (часто в мессенджерах используются никнеймы, а твоё реальное имя он мог забыть), назвать свой возраст, образование, рассказать о предыдущих местах работы и должностях, сколько лет в индустрии, какие ЯП и технологии использовал - только "по верхам", для того чтоб твой собеседник просто понял с кем он "имеет дело".

## Расскажи о своем самом интересном проекте?

К этому вопросу есть смысл подготовиться заранее и не спустя рукава. Дело в том, что это тот момент, когда тебе надо подобно павлину распустить хвост и создать правильное первое впечатление о себе, так как этот вопрос чаще всего идёт первым. Возьми и выпиши для себя где-нибудь на листочке основные тезисы о том, что это был за проект/сервис/задача, уделяя основное внимание тому какой профит это принесло для компании/команды в целом. Например:

- Я со своей командой гоферов из N человек в течении трех месяцев создали аналог сервиса у которого компания покупала данные за $4000 в месяц, а после перехода на наш сервис - расходы сократились до $1500 в месяц и значительно повысилось их качество и uptime;
- Внедренные мной практики в CI/CD пайплайны позволили сократить время на ревью изменений в проектах на 25..40%, а зная сколько стоит время работы разработчиков - вы сами всё понимаете;
- Разработанный мной сервис состоял из такого-то набора микросервисов, такие-то службы и протоколы использовал, были такие-то ключевые проблемы которые мы так-то зарешали; основной ценностью было то-то.

## Что такое ООП? Как это сделано в Golang?

ООП это методология (подход) программирования, основанный на том, что программа представляет собой некоторую совокупность объектов-классов, которые образую иерархию наследования. Ключевые фишки - минимализация повторяемости кода ([принцип DRY][dry]) и удобство понимания/управления. Фундаментом ООП можно считать идею описания объектов в программировании подобно объектам из реального мира - у них есть свойства, поведение, они могут взаимодействовать. Мы (люди) так понимаем мир, и нам (людям) так проще описывать всякие штуки в коде. Основные принципы в ООП:

- **Абстракция** вообще присуща для любого программирования, а не только для ООП. По большому счету (топорный, но понятный пример) это про выделение общего и объединение этого в какие-то сущности но без реализации, про контракты. Например - экземпляры абстрактных классов не могут быть созданы (`new AbstractClass`), но могут содержать абстрактные методы, чтоб разработчик решив наследоваться от этого абстрактного класса их реализовал так, как ему нужно для своих целей (например - ходить в SQL СУБД или файл). Другой пример - это интерфейсы, они же контракты чистой воды - содержат только сигнатуры методов и ни капельки реализации. Но абстракция не ограничивается ими и должна быть умеренной, так как усложняет архитектуру приложения в общем и целом. Опираться следует на интуицию и опыт. Слишком много слоев абстракции (ещё раз - тут дело не ограничивается интерфейсами и абстрактными классами) приводит к переусложнению и головной боли последующего сопровождения продукта. Недостаточная - к сложности внесения изменений и расширению функционала.

- **Инкапсуляция** про контроль доступа к свойствам объекта и их динамическая валидация/преобразования. Если метод/свойство должно быть доступно "из вне" объекта - объявляем публичным, иначе - приватным. Если есть необходимость переопределять его из потомков класса - то защищенным (protected). Python, например, реализуют инкапсуляцию, но не предусматривает возможности сокрытия в принципе; в то время как С++ и Java она просто всюду.

- **Наследование** это возможность (барабанная дробь!) наследоваться одним объектам от других, "перенимая" все методы родительских объектов. Своеобразный вариант Матрешки. Т.е. выделяя в родительских объектах "всё общее" мы можем не повторяться в реализации частных, а просто "наследоваться".

- **Полиморфизм** - "поли" - много, "морф" - вид. Везде, где есть интерфейсы - подразумевается полиморфизм. Суть - это контракты (интерфейсы), мы можем объявить "что-то умеет закрывать себя методом `Close()`", и нам не важно что именно это будет. Реализаций может быть много, и если это что-то умеет делать то, что нам надо - нам удобнее с этим работать.

Тут же можно упомянуть про знание [SOLID][solid], а именно:

- **S** (single responsibility principle, принцип единственной ответственности) - определенный класс/модуль должен решать только определенную задачу, максимально узко но максимально хорошо (своеобразные UNIX-way). Если для выполнения своей задачи ему требуются какие-то другие ресурсы - они в него должны быть инкапсулированы (это отсылка к принципу инверсии зависимостей).

- **O** (open-closed principle, принцип открытости/закрытости) - классы/модули должны быть открыты для расширения, но закрыты для модификации. Должна быть возможность расширить поведение, наделить новым функционалом, но при этом исходный код/логика модуля должна быть неизменной.

- **L** (Liskov substitution principle, принцип подстановки Лисков) - поведение наследующих классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследующих классов должно быть ожидаемым для кода.

- **I** (interface segregation principle, принцип разделения интерфейса) - много тонких интерфейсов лучше, чем один толстый.

- **D** (dependency inversion principle, принцип инверсии зависимостей) - "завязываться" на абстракциях (интерфейсах), а не конкретных реализациях. Так же (это уже про IoC, но всё же) можно рассказать что если какому-то классу для своей работы требуется функциональность другого - то есть смысл "запрашивать" её в конструкторе нашего класса используя _интерфейс_, под который подходит наша зависимость. Таким образом целевая реализация опирается только на интерфейсы (не зависит от реализаций) и соответствует принципу под буквой **S**.

А теперь о том, как это реализовано в Go (наконец-то!).

В Go нет классов, объектов, исключений и шаблонов. Нет иерархии типов, но есть сами типы (т.е. возможность описывать свои типы/структуры). Структурные типы (с методами) служат тем же целям, что и классы в других языках. Так же следует упомянуть что структура определяет состояние.

В Go нет наследования. Совсем. Но есть встраивание (называемое "анонимным", так как `Foo` в `Bar` встраивается не под каким-то именем, а без него) при этом встраиваются и свойства, и функции:

```go
import "fmt"

type Foo struct {
	name    string
	Surname string
}

func (f Foo) SayName() string { return f.name }

type Bar struct {
	Foo
}

func main() {
	bar := Bar{Foo{name: "one", Surname: "baz"}}

	fmt.Println(bar.SayName()) // one
	fmt.Println(bar.Surname)   // baz

	bar.name = "two"

	fmt.Println(bar.SayName()) // two
}
```

Есть интерфейсы (это типы, которые объявляют наборы методов). Подобно интерфейсам в других языках, они не имеют реализации. Объекты, которые реализуют все методы интерфейса, автоматически реализуют интерфейс (так называемый **Duck-typing**). Не существует наследования или подклассов или ключевого слова `Implements`:

```go
import "fmt"

type Speaker interface {
	Speak() string
}

type Foo struct{}

func (Foo) Speak() string { return "foo" }

type Bar struct{}

func (Bar) Speak() string { return "bar" }

func main() {
	var foo, bar Speaker = new(Foo), &Bar{}

	fmt.Println(foo.Speak()) // foo
	fmt.Println(bar.Speak()) // bar
}
```

А примере выше мы объявили переменные `foo` и `bar` с явным указанием интерфейсного типа, а так интерфейс это ссылочный тип - то и структуры мы инициализировали ссылками на них с использованием `new()` (что аллоцирует структуру с возвращает ссылку на неё) и (или) `&`.

**Инкапсуляция** реализована на уровне пакетов. Имена, начинающиеся со строчной буквы, видны только внутри этого пакета (не являются экспортируемыми). И наоборот - всё, что начинается с заглавной буквы - доступно из-вне пакета. Дешево и сердито.

**Полиморфизм** - это основа объектно-ориентированного программирования: способность обрабатывать объекты разных типов одинаково, если они придерживаются одного и того же интерфейса. Интерфейсы Go предоставляют эту возможность очень прямым и интуитивно понятным способом. Пример использования интерфайса был описан выше.

Отдельно хочется сказать про принцип инверсии зависимостей (dependency inversion principle), который можно реализовывать следующим образом:

```go
import (
	"errors"
	"fmt"
)

type speaker interface {
	Speak() string
}

type Foo struct {
	s speaker
}

func NewFoo(s speaker) (*Foo, error) {
	if s == nil {
		return nil, errors.New("speaker is nil")
	}

	return &Foo{s: s}, nil
}

func (f Foo) SaySomething() string { return f.s.Speak() }

func main() {
	var foo, err = NewFoo(someSpeaker)

	if err != nil {
		panic(err)
	}

	fmt.Println(foo.SaySomething()) // depends on the speaker implementation
}
```

Мы объявляем интерфейс `speaker` не экспортируемым на нашей, принимающей стороне, и используя псевдо-конструктор `NewFoo` гарантируем что свойство `s` будет проинициализировано верным типом (дополнительно проверяя его на `nil`). Таким образом мы инвертируем зависимость.

> Что можно почитать:
> - [ООП в картинках](https://habr.com/ru/post/463125/)
> - [Golang и ООП](https://habr.com/ru/post/243593/)

[dry]:https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself
[solid]:https://en.wikipedia.org/wiki/SOLID

## В чём ключевое отличие слайса (среза) от массива?

### TL;DR

- Срез - всегда ссылка на массив, массив - значение
- Срез может менять свой размер и динамически аллоцировать память

> В Go не бывает ссылок - но есть указатели. Где говорится про "по ссылке" имеется в виду "по указателю"

### Развёрнуто

Слайсы и массивы в Go это проиндексированные упорядоченные структуры данных последовательностей элементов. Ёмкость **массива** объявляется в момент его создания, и после изменить её уже нельзя (его длина это часть его типа). Память, необходимая для хранения элементов массива выделяется соответственно сразу при его объявлении, и по умолчанию инициализируется в соответствии с нулевыми значением для типа (`fasle` для `bool`, `0` для `int`, `nil` для интерфейсов и т.д.). В качестве размера можно использовать константы (компилятор должен знать это значение на этапе компиляции, т.е. что-то вида `var a [getSize()]int` или `i := 3; var a [i]int` недопустимо):

```go
const mySize uint8 = 8

type myArray [mySize]byte

var constSized = [...]int{1, 2, 3} // размер сам посчитается исходя из кол-ва эл-ов
```

Кстати, **массивы** с элементами одного типа но с **разными** размерами являются **разными** типами. Массивы **не нужно** инициализировать явно; нулевой массив - это готовый к использованию массив, элементы которого являются нулями:

```go
var a [4]int // [0 0 0 0]

a[0] = 1  // [1 0 0 0]
i := a[0] // i == 1
```

Представление `[4]int` в памяти - это просто четыре целых значения, расположенных последовательно. Так же следует помнить что в Go **массивы передаются по значению**, т.е. передавая массив в какую-либо функцию она получает **копию массива** _(для его передачи по ссылке нужно явно это указывать, т.е. `foo(&a)`)_.

А **слайс** же это своего рода версия массива но с вариативным размером (структура данных, которая строится поверх массива и предоставляет доступ к элементами базового массива). Если посмотреть исходники Go ([src/runtime/slice.go](https://github.com/golang/go/blob/36b81acfa19d9fedf6a0cd60c394fd7a7703834e/src/runtime/slice.go#L15-L19)), то увидим:

```go
type slice struct {
	array unsafe.Pointer // указатель на массив
	len   int            // длина (length)
	cap   int            // вместимость (capacity)
}
```

Для аллокации слайса можно воспользоваться одной из команд ниже:

```go
var (
	a = []int{}            // []              len=0 cap=0
	b = []int{1, 2}        // [1 2]           len=2 cap=2
	c = []int{5: 1}        // [0 0 0 0 0 123] len=6 cap=6
	d = make([]int, 5, 10) // [0 0 0 0 0]     len=5 cap=10
)
```

В последнем случае рантайм Go создаст массив из 10 элементов (выделит память и заполнит их нулями) но **доступны прямо сейчас** нам будут только 5, и установит значения `len` в `5`, а `cap` в `10`. `Cap` означает ёмкость и помогает зарезервировать место в памяти на будущее, чтобы избежать лишних операций выделения памяти при росте слайса (это ключевой параметр для аллокации памяти, влияет на производительность вставки в срез). При добавлении новых элементов в слайс новый массив для него не будет создаваться до тех пор, пока `cap` меньше `len`.

**Слайсы передаются по ссылке** _(фактически будет передана копия структуры `slice` со своими `len` и `cap`, но указатель на массив `array` будет тот-же самый)_. Для защиты слайса от изменений следует передавать его копию:

```go
var (
	a = []int{1, 2, 0, 0, 1}
	b = make([]int, len(a))
)

copy(b, a)

fmt.Println(a, b) // [1 2 0 0 1] [1 2 0 0 1]
```

Важной особенностью является то, так как "под капотом" у слайса лежит ссылка на массив - при изменении значений слайса они будут изменяться везде, где слайс используется (будь то присвоение в переменную, передача в функцию и т.д.) до момента, пока размер слайса не будет переполнен и не будет выделен новый массив для его значений (т.е. в момент изменения `cap` слайса всегда происходит **копирование** данных массива):

```go
var (
	one = []int{1, 2} // [1 2]
	two = one         // [1 2]
)

two[0] = 123

fmt.Println(one, two) // [123 2] [123 2]

one = append(one, 666)

fmt.Println(one, two) // [123 2 666] [123 2]
```

> Что можно почитать:
> - [Как не наступать на грабли в Go](https://habrahabr.ru/post/325468/#slaysy)
> - [Слайсы в Go: использование и особенности](https://www.vld.by/slices-in-go)
> - [Принцип работы типа slice в GO](https://golangforall.com/ru/post/golang-slice.html)

## Как работает `append` в слайсе?

`append()` делает простую операцию - добавляет элементы в слайс и возвращает новый. Но под капотом там делаются довольно сложные манипуляции, чтобы выделять память только при необходимости и делать это эффективно.

Сперва `append` сравнивает значения `len` и `cap` у слайса. Если `len` меньше чем `cap`, то значение `len` увеличивается, а само добавляемое значение помещается в конец слайса. В противном случае происходит выделение памяти под новый массив для элементов слайса, в него копируются значения из старого, и значение помещается уже в новый массив.

[Увеличении размера слайса (метод `growslice`)](https://github.com/golang/go/blob/36b81acfa19d9fedf6a0cd60c394fd7a7703834e/src/runtime/slice.go#L188-L211) происходит по следующему алгоритму - если его размер **менее 1024** элементов, то его размер будет увеличиваться вдвое; иначе же слайс увеличивается на ~12.5% от своего текущего размера.

Что важно помнить - если на основании слайса `one` выделить подслайс `two`, а затем увеличим слайс `one` (и его вместимость будет превышена) - то `one` и `two` будут уже ссылаться на разные участки памяти!

```go
var (
	one = make([]int, 4) // [0 0 0 0]
	two = one[1:3]       // [0 0]
)

one[2] = 11

fmt.Println(one, two)           // [0 0 11 0] [0 11]
fmt.Printf("%p %p\n", one, two) // 0xc0000161c0 0xc0000161c8

one = append(one, 1)

fmt.Printf("%p %p\n", one, two) // 0xc00001c1c0 0xc0000161c8

one[2] = 22

fmt.Println(one, two)           // [0 0 22 0 1] [0 11]
fmt.Printf("%p %p\n", one, two) // 0xc00001c1c0 0xc0000161c8
```

> Что можно почитать:
> - [Как не наступать на грабли в Go](https://habrahabr.ru/post/325468/#dobavlenie-k-slaysu-append)

## Задача про слайсы #1

### Вопрос

У нас есть 2 функции - одна делает `append()` чего-то в слайс, а другая просто сортирует слайс, используя пакет `sort`. Модифицируют ли слайс первая и (или) вторая функции?

### Ответ

`append()` не модифицирует а возвращает новый слайс, а `sort` модифицирует порядок элементов, если он изначально был не отсортирован.

## Что можно сказать про `map`?

Карта (`map` или `hashmap`) — это **неупорядоченная** коллекция пар вида ключ-значение. Пример:

```go
type myMap map[string]int
```

Подобно массивам и слайсам, к элементам мапы можно обратиться с помощью скобок:

```go
var m = make(map[string]int)

m["one"] = 1

fmt.Println(m["one"], m["two"]) // 1 0
```

> Лучше выделить память заранее (передавая вторым аргументом функции `make`), если известно количество элементов - избежим эвакуаций

В случае с `m["two"]` вернулся `0` так как это является нулевым значением для типа `int`. Для проверки существования ключа используем конструкцию вида (доступ к элементу карты может вернуть два значения вместо одного) называемую "multiple assignment":

```go
var m = map[string]int{"one": 1}

v1, ok1 := m["one"]
v2, ok2 := m["two"]

fmt.Println(v1, ok1) // 1 true
fmt.Println(v2, ok2) // 0 false

delete(m, "one")

v1, ok1 = m["one"]

fmt.Println(v1, ok1) // 0 false
```

Мапы всегда **передаются по ссылке** _(вообще-то Go не бывает ссылок, невозможно создать 2 переменные с 1 адресом, как в С++ например; но зато можно создать 2 переменные, указывающие на один адрес - но это уже указатели)_. Если же быть точнее, то мапа в Go — это просто **указатель** на [структуру `hmap`](https://github.com/golang/go/blob/36b81acfa19d9fedf6a0cd60c394fd7a7703834e/src/runtime/map.go#L116-L130):


```go
type hmap struct {
	// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
	// Make sure this stays in sync with the compiler's definition.
	count     int // # live cells == size of map.  Must be first (used by len() builtin)
	flags     uint8
	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
	hash0     uint32 // hash seed

	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

	extra *mapextra // optional fields
}
```

Так же структура `hmap` содержит в себе следующее:

- Количество элементов
- Количество "ведер" (представлено в виде логарифма для ускорения вычислений)
- Seed для рандомизации хэшей (чтобы было сложнее заddosить — попытаться подобрать ключи так, что будут сплошные коллизии)
- Всякие служебные поля и главное указатель на buckets, где хранятся значения

![hmap](hmap.png)

На картинке схематичное изображение структуры в памяти — есть хэдер hmap, указатель на который и есть map в Go (именно он создается при объявлении с помощью var, но не инициализируется, из-за чего падает программа при попытке вставки). Поле `buckets` — хранилище пар ключ-значение, таких "ведер" несколько, в каждом лежит 8 пар. Сначала в "ведре" лежат слоты для дополнительных битов хэшей (`e0..e7` названо `e` — потому что extra hash bits). Далее лежат ключи и значения как сначала список всех ключей, потом список всех значений.

По хэш функции определяется в какое "ведро" мы кладем значение, внутри каждого "ведра" может лежать до 8 коллизий, в конце каждого "ведра" есть указатель на дополнительное, если вдруг предыдущее переполнилось.

### Как растет `map`?

В исходном коде можно [найти строчку](https://github.com/golang/go/blob/36b81acfa19d9fedf6a0cd60c394fd7a7703834e/src/runtime/map.go#L69) `Maximum average load of a bucket that triggers growth is 6.5`. То есть, если в каждом "ведре" в среднем более 6,5 элементов, происходит увеличение массива `buckets`. При этом выделяется массив **в 2 раза больше**, а старые данные копируются в него маленькими порциями каждые вставку или удаление, чтобы не создавать очень крупные задержки. Поэтому все операции будут чуть медленнее в процессе **эвакуации данных** (при поиске тоже, нам же приходится искать в двух местах). После успешной эвакуации начинают использоваться новые данные.

Из-за эвакуации данных нельзя и взять адрес мапы - представьте, что мы взяли адрес значения, а потом мапа выросла, выделилась новая память, данные эвакуировались, старые удалились, указатель стал неправильным, поэтому такие операции запрещены.

### Что там про поиск?

Поиск, если разобраться, устроен не так уж и сложно: проходимся по цепочкам "ведер", переходя в следующее, если в этом не нашли. Поиск в "ведре" начинается с быстрого сравнения дополнительного хэша (вот для чего эти `e0...e7` в начале каждого — это "мини" хэш пары для быстрого сравнения). Если не совпало, идем дальше, если совпало, то проверяем тщательнее — определяем где лежит в памяти ключ, подозреваемый как искомый, сравниваем равен ли он тому, что запросили. Если равен, определяем положение значения в памяти и возвращаем.

> Что можно почитать:
> - [Хэш таблицы в Go. Детали реализации](https://habr.com/ru/post/457728/)

## Есть ли у `map` такие же методы как у слайса: `len`, `cap`?

У мапы есть `len` но нет `cap`. У нас есть только `overflow` который указывает "куда-то" когда мапа переполняется, и поэтому у нас не может быть `capacity`.

## Какие типы ключей разрешены для ключа в `map`?

Любым **сравнимым** (comparable) типом, т.е. булевы, числовые, строковые, указатели, канальные и интерфейсные типы, а также **структуры** или **массивы**, содержащие только эти типы. Слайсы, мапы и функции использовать нельзя, так как эти типы не сравнить с помощью оператора `==` или `!=`.

## Может ли ключом быть структура? Если может, то всегда ли?

Как было сказано выше - структура может быть ключом до тех пор, пока мы в поля структуры не поместим какой-либо слайс, мапу или любой другой non-comparable тип данных.

## Что будет в `map`, если не делать `make` или `short assign`?

Будет паника (например - при попытке что-нибудь в неё поместить), так как любые "структурные" типы (а мапа как мы знаем таковой является) должны быть инициализированы для работы с ними.

## Что можешь рассказать про escape analysis?

_WIP_

> Что можно почитать:
> - [Языковая механика escape analysis](https://habr.com/ru/post/497994/)

## Что такое synс.Map ?

_WIP_

## Как устроен Duck-typing в Go?

_WIP_

## Race condition. Потокобезопасна ли мапа?

_WIP_

## Как задетектить гонку?

_WIP_

## Что есть интерфейс?

_WIP_

## Дополнительный блок фигурных скобок в функции

_WIP_

## Что такое замыкание?

_WIP_

## Что такое захват переменной?

_WIP_

## Какое поведение по умолчанию используется в golang при передаче в функцию?

_WIP_

## Сколько можно возвращать значений из функции?

_WIP_

## Как сделать свои методы для пакета?

_WIP_

## Инвертирование зависимости

_WIP_

## Какие типы каналов существуют?

_WIP_

## Что можно делать с закрытым каналом?

_WIP_

## Что если канал интовый и был получен ноль?

_WIP_

## Аналог default в select'е

_WIP_

## Что такое горутина?

_WIP_

## Где аллоцируется память для горутин?

_WIP_

## Что такое WaitGroup и зачем они нужны?

_WIP_

## Как завершить много горутин?

_WIP_

## Кейсы использования контекста

_WIP_

## Кейс по system design

_WIP_

## Какую архитектуру API Даниил бы выбрал для кейса?

_WIP_

## Какие бывают версии HTTP?

_WIP_

## Какие Devops тулзы можно использовать для кейса?

_WIP_

## Как бы был устроен деплой для этого кейса?

_WIP_

## Тестирование

<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" Данная статья является копией публикации на хабре
 В данной статье я расскажу о своём опыте &amp;ldquo;заворачивания&amp;rdquo; Laravel-приложения в Docker-контейнер да так, что бы и локально с ним могли работать frontend и backend разработчики, и запуск его на production был максимально прост. Так же CI будет автоматически запускать статические анализаторы кода, phpunit-тесты, производить сборку образов.
"><title>Docker + Laravel = ❤</title><link rel=canonical href=https://blog.hook.sh/laravel-in-docker/><link rel=stylesheet href=https://blog.hook.sh/scss/style.min.c81ad01c194dc8cda208713c6fcb1aa14f50b41ffb0f7a7aa16860ae4d9babdc.css><meta property="og:title" content="Docker + Laravel = ❤"><meta property="og:description" content=" Данная статья является копией публикации на хабре
 В данной статье я расскажу о своём опыте &amp;ldquo;заворачивания&amp;rdquo; Laravel-приложения в Docker-контейнер да так, что бы и локально с ним могли работать frontend и backend разработчики, и запуск его на production был максимально прост. Так же CI будет автоматически запускать статические анализаторы кода, phpunit-тесты, производить сборку образов.
"><meta property="og:url" content="https://blog.hook.sh/laravel-in-docker/"><meta property="og:site_name" content="blog [dot] hook"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="php"><meta property="article:tag" content="devops"><meta property="article:tag" content="linux"><meta property="article:tag" content="docker"><meta property="article:published_time" content="2018-10-01T08:29:51+00:00"><meta property="article:modified_time" content="2018-10-01T08:29:51+00:00"><meta property="og:image" content="https://blog.hook.sh/laravel-in-docker/cover.png"><meta name=twitter:title content="Docker + Laravel = ❤"><meta name=twitter:description content=" Данная статья является копией публикации на хабре
 В данной статье я расскажу о своём опыте &amp;ldquo;заворачивания&amp;rdquo; Laravel-приложения в Docker-контейнер да так, что бы и локально с ним могли работать frontend и backend разработчики, и запуск его на production был максимально прост. Так же CI будет автоматически запускать статические анализаторы кода, phpunit-тесты, производить сборку образов.
"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.hook.sh/laravel-in-docker/cover.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-1B4Z5Q844N"></script><script>var dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-1B4Z5Q844N',{anonymize_ip:!0})}</script><link rel=apple-touch-icon sizes=180x180 href="https://blog.hook.sh/apple-touch-icon.png?v=1633428055"><link rel=icon type=image/png sizes=32x32 href="https://blog.hook.sh/favicon-32x32.png?v=1633428055"><link rel=icon type=image/png sizes=16x16 href="https://blog.hook.sh/favicon-16x16.png?v=1633428055"><link rel=manifest href=https://blog.hook.sh/webmanifest.json><meta name=msapplication-TileColor content="#303030"><meta name=theme-color content="#303030"></head><body class="article-page has-toc"><script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"dark")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://blog.hook.sh/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Назад</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/laravel-in-docker/><img src=/laravel-in-docker/cover_hua8f71ffb89a9e5aa8906e7ae93fcb2fc_87557_800x0_resize_box_2.png srcset="/laravel-in-docker/cover_hua8f71ffb89a9e5aa8906e7ae93fcb2fc_87557_800x0_resize_box_2.png 800w, /laravel-in-docker/cover_hua8f71ffb89a9e5aa8906e7ae93fcb2fc_87557_1600x0_resize_box_2.png 1600w" width=800 height=303 loading=lazy alt="Featured image of post Docker + Laravel = ❤"></a></div><div class=article-details><header class=article-category><a href=/categories/php/ style=background-color:#6b74a2;color:#fff>PHP</a>
<a href=/categories/docker/ style=background-color:#0090f4;color:#fff>Docker</a></header><h2 class=article-title><a href=/laravel-in-docker/>Docker + Laravel = ❤</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2018.10.01</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>Время чтения: 12 мин.</time></div></footer></div></header><section class=article-content><div class=outdated-post style=display:none data-posted-at=2018-10-01><strong>Внимание!</strong> Данный пост был опубликован более года назад и, возможно, уже утратил свою былую актуальность. Но это не точно.</div><blockquote><p>Данная статья является копией <a class=link href=https://habr.com/post/425101/ target=_blank rel=noopener>публикации на хабре</a></p></blockquote><p>В данной статье я расскажу о своём опыте &ldquo;заворачивания&rdquo; Laravel-приложения в Docker-контейнер да так, что бы и локально с ним могли работать frontend и backend разработчики, и запуск его на production был максимально прост. Так же CI будет автоматически запускать статические анализаторы кода, <code>phpunit</code>-тесты, производить сборку образов.</p><p>&ldquo;А в чём, собственно, сложность?&rdquo; - можешь сказать ты, и будешь отчасти прав. Дело в том, что этой теме посвящено довольно много обсуждений в русскоязычных и англоязычных комьюнити, и почти все изученные треды я бы условно разделил на следующие категории:</p><ul><li>&ldquo;Использую докер для локальной разработки. Ставлю <a class=link href=https://laradock.io/ target=_blank rel=noopener>laradock</a> и беды не знаю&rdquo;. Круто, но как обстоят дела с автоматизацией и запуском на production?</li><li>&ldquo;Собираю один контейнер <em>(монолит)</em> на базе <code>fedora:latest</code> (~230 Mb), ставлю в него все сервисы (nginx, бд, кэш, etc), запускаю всё супервизором внутри&rdquo;. Тоже отлично, прост в запуске, но как на счёт идеологии &ldquo;один контейнер - один процесс&rdquo;? Как обстоят дела с балансировкой и управлением процессами? Как же размер образа?</li><li>&ldquo;Вот вам куски конфигов, приправляем выдержками из sh-скриптов, добавим магических env-значений, пользуйтесь&rdquo;. Спасибо, но как же на счёт хотя бы одного живого примера, который я бы мог форкнуть и полноценно поиграться?</li></ul><p>Всё, что ты прочитаешь ниже - является субъективным опытом, который не претендует быть истиной в последней инстанции. Если у тебя будут дополнения или указания на неточности - welcome to comments.</p><blockquote><p>Для нетерпеливых - <a class=link href=https://gitlab.com/tarampampam/laravel-in-docker target=_blank rel=noopener>ссылка на репозиторий</a>, склонировав который ты сможешь запустить Laravel-приложение одной командой. Так же не составит труда его запустить на том же <a class=link href=https://rancher.com/ target=_blank rel=noopener>rancher</a>, правильно &ldquo;слинковав&rdquo; контейнеры, или использовать продуктовый вариант <code>docker-compose.yml</code> как отправную точку.</p></blockquote><h2 id=часть-теоретическая>Часть теоретическая</h2><p>Какие инструменты мы будем использовать в своей работе, и на что сделаем акценты? Первым делом нам понадобятся установленные на хосте:</p><ul><li><code>docker</code> - на момент написания статьи использовал версию <code>18.06.1-ce</code></li><li><code>docker-compose</code> - он отлично справляется с линковкой контейнеров и хранением необходимых environment значений; версия <code>1.22.0</code></li><li><code>make</code> - возможно ты удивишься, но он отлично &ldquo;вписывается&rdquo; в контекст работы с докером</li></ul><blockquote><p>Поставить <code>docker</code> на <code>debian</code>-like системы можно командой <code>curl -fsSL get.docker.com | sudo sh</code>, а вот <code>docker-compose</code> лучше ставь с помощью <code>pip</code>, так как в его репозиториях обитают наиболее свежие версии (<code>apt</code> сильно отстают, как правило).</p></blockquote><p>На этом список зависимостей можно завершить. Что ты будешь использовать для работы с исходниками - <code>phpstorm</code>, <code>netbeans</code> или трушный <code>vim</code> - только тебе решать.</p><p>Дальше - импровизированный QA в контексте <em>(не побоюсь этого слова)</em> проектирования образов:</p><ul><li><p><strong>Q: Базовый образ - какой лучше выбрать?</strong></p></li><li><p><strong>A:</strong> Тот, что &ldquo;потоньше&rdquo;, без излишеств. На базе <a class=link href=https://hub.docker.com/_/alpine/ target=_blank rel=noopener><code>alpine</code></a> <em>(~5 Mb)</em> можно собрать всё, что душе угодно, но скорее всего придётся поиграться со сборкой сервисов из исходников. Как альтернатива - <a class=link href=https://hub.docker.com/_/debian/ target=_blank rel=noopener><code>jessie-slim</code></a> <em>(~30 Mb)</em>. Или же использовать тот, что наиболее часто используется у вас на проектах.</p></li><li><p><strong>Q: Почему вес образа - это важно?</strong></p></li><li><p><strong>A:</strong> Снижение объёма трафика, снижение вероятности ошибки при скачивании (меньше данных - меньше вероятность), снижение потребляемого места. Правило &ldquo;Тяжесть — это надёжно&rdquo; (© &ldquo;Snatch&rdquo;) тут не очень работает.</p></li><li><p><strong>Q: А вот мой друг <code>%friend_name%</code> говорит, что &ldquo;монолитный&rdquo; образ со всеми-всеми зависимостями - это самый лучший путь.</strong></p></li><li><p><strong>A:</strong> Давай просто посчитаем. Приложение имеет 3 зависимости - PG, Redis, PHP. И тебе захотелось протестировать как оно у тебя будет себя вести в связках различных версий этих зависимостей. PG - версии 9.6 и 10, Redis - 3.2 и 4.0, PHP - 7.0 и 7.2. В случае, если каждая зависимость это отдельный образ - тебе их потребуется 6 штук, которые даже собирать не надо - всё уже готово и лежит на <code>hub.docker.com</code>. Если же по идеологическим соображениям все зависимости &ldquo;упакованы&rdquo; в один контейнер, тебе придётся его ручками пересобрать&mldr; 8 раз? А теперь добавь условие, что ты ещё хочешь и с <code>opcache</code> поиграться. В случае декомпозиции - это просто изменение тегов используемых образов. Монолит проще запускать и обслуживать, но это путь в никуда.</p></li><li><p><strong>Q: Почему супервизор в контейнере - это зло?</strong></p></li><li><p><strong>A:</strong> Потому что <code>PID 1</code>. Не хочешь обилия проблем с зомби-процессами и иметь возможность гибко &ldquo;добавлять мощностей&rdquo; там, где это необходимо - старайся запускать один процесс на контейнер. Своеобразными исключениями является <code>nginx</code> со своими воркерами и <code>php-fpm</code>, которые имеют свойство плодить процессы, но с этим приходится мириться (более того - они не плохо умеют реагировать на <code>SIGTERM</code>, вполне корректно &ldquo;убивая&rdquo; своих воркеров). Запустив же всех демонов супервизором - фактически наверняка ты обрекаешь себя на проблемы. Хотя, в некоторых случаях - без него сложно обойтись, но это уже исключения.</p></li></ul><p>Определившись с основными подходами давай перейдём к нашему приложению. Оно должно уметь:</p><ul><li><code>web|api</code> - отдавать статику силами <code>nginx</code>, а динамический контент генерировать силами <code>fpm</code></li><li><code>scheduler</code> - запускать родной планировщик задач</li><li><code>queue</code> - обрабатывать задания из очередей</li></ul><p>Базовый набор, который при необходимости можно будет расширить. Теперь перейдём к образам, которые нам предстоит собрать для того, что бы наше приложение &ldquo;взлетело&rdquo; (в скобках приведены их кодовые имена):</p><ul><li><code>PHP + PHP-FPM</code> (<strong>app</strong>) - среда, в которой будет выполняться наш код. Так как версии PHP и FPM у нас будут совпадать - собираем их в одном образе. Так и с конфигами легче управляться, и состав пакетов будет идентичный. Разумеется - FPM и процессы приложения будут запускаться в разных контейнерах</li><li><code>nginx</code> (<strong>nginx</strong>) - что бы не заморачиваться с доставкой конфигов и опциональных модулей для <code>nginx</code> - будем собирать отдельный образ с ним. Так как он является отдельным сервисом - у него свой докер-файл и свой контекст</li><li>Исходники приложения (<strong>sources</strong>) - доставка исходников будет производиться используя отдельный образ, монтируя <code>volume</code> с ними в контейнер с app. Базовый образ - <code>alpine</code>, внутри - только исходники с установленными зависимостями и собранными с помощью webpack asset-ами (артефакты сборки)</li></ul><p>Остальные сервисы для разработки запускаются в контейнерах, стянув их с <code>hub.docker.com</code>; на production же - они запущены на отдельных серверах, объединенных в кластеры. Всё что нам останется - это сказать приложению <em>(через environment)</em> по каким адресам\портам и с какими реквизитами необходимо до них стучаться. Ещё круче - это использовать в этих целях service-discovery, но об этом не в этот раз.</p><p>Определившись с частью теоретической - предлагаю перейти к следующей части.</p><h2 id=часть-практическая>Часть практическая</h2><p>Организовать файлы в репозитории предлагаю следующим образом:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>.
├── docker  <span class=c1># Директория для хранения докер-файлов необходимых сервисов</span>
│   ├── app
│   │   ├── Dockerfile
│   │   └── ...
│   ├── nginx
│   │   ├── Dockerfile
│   │   └── ...
│   └── sources
│       ├── Dockerfile
│       └── ...
├── src  <span class=c1># Исходники приложения</span>
│   ├── app
│   ├── bootstrap
│   ├── config
│   ├── artisan
│   └── ...
├── docker-compose.yml  <span class=c1># Compose-конфиг для локальной разработки</span>
├── Makefile
├── CHANGELOG.md
└── README.md
</code></pre></div><blockquote><p>Ознакомиться со структурой и файлами ты можешь перейдя по <a class=link href=https://gitlab.com/tarampampam/laravel-in-docker target=_blank rel=noopener>этой ссылке</a>.</p></blockquote><p>Для сборки того или иного сервиса можно воспользоваться командой:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ docker build <span class=se>\
</span><span class=se></span>  --tag %local_image_name% <span class=se>\
</span><span class=se></span>  -f ./docker/%service_directory%/Dockerfile ./docker/%service_directory%
</code></pre></div><p>Единственным отличием будет сборка образа с исходниками - для него необходимо контекст сборки (крайний аргумент) указать равным <code>./src</code>.</p><p>Правила именования образов в локальном registry рекомендую использовать те, что использует <code>docker-compose</code> по умолчанию, а именно: <code>%root_directory_name%_%service_name%</code>. Если директория с проектом называется <code>my-awesome-project</code>, а сервис носит имя <code>redis</code>, то имя образа (локального) лучше выбрать <code>my-awesome-project_redis</code> соответственно.</p><blockquote><p>Для ускорения процесса сборки можно сказать докеру использовать кэш ранее собранного образа, и для этого используется параметр запуска <code>--cache-from %full_registry_name%</code>. Таким образом демон докера перед запуском той или иной инструкции в Dockerfile посмотрит - изменились ли она? И если нет (хэш сойдётся) - он пропустит инструкцию, используя уже готовый слой из образа, который ты укажешь ему использовать в качестве кэша. Эта штука не плохо так бустит процесс пересборки, особенно, если ничего не изменилось :)</p></blockquote><blockquote><p>Обрати внимание на <code>ENTRYPOINT</code> скрипты запуска контейнеров приложения.</p></blockquote><p>Образ среды для запуска приложения (app) собирался с учётом того, что он будет работать не только на production, но ещё и локально разработчикам необходимо с ним эффективно взаимодействовать. Установка и удаление <code>composer</code>-зависимостей, запуск <code>unit</code>-тестов, <code>tail</code> логов и использование привычных алиасов (<code>php /app/artisan</code> → <code>art</code>, <code>composer</code> → <code>c</code>) должно быть без какого либо дискомфорта. Более того - он же будет использоваться для запуска <code>unit</code>-тестов и статических анализаторов кода (<code>phpstan</code> в нашем случае) на CI. Именно поэтому его Dockerfile, к примеру, содержит строчку установки <code>xdebug</code>, но сам модуль не включен (он включается только с использованием CI).</p><blockquote><p>Так же для <code>composer</code> глобально ставится пакет <code>hirak/prestissimo</code>, который сильно бустит процесс установки всех зависимостей.</p></blockquote><p>На production мы монтируем внутрь него в директорию <code>/app</code> содержимое директории <code>/src</code> из образа с исходниками (sources). Для разработки - &ldquo;прокидываем&rdquo; локальную директорию с исходниками приложения (<code>-v "$(pwd)/src:/app:rw"</code>).</p><p>И вот тут кроется одна сложность - это <strong>права доступа на файлы</strong>, которые создаются из контейнера. Дело в том что по умолчанию процессы, запущенные внутри контейнера - запускаются от рута (<code>root:root</code>), создаваемые этими процессами файлы (кэш, логи, сессии, etc) - тоже, и как следствие - &ldquo;локально&rdquo; с ними ты уже ничего не сможешь сделать, не выполнив <code>sudo chown -R $(id -u):$(id -g) /path/to/sources</code>.</p><p>Как один из вариантов решения - это использование <a class=link href=https://boxboat.com/2017/07/25/fixuid-change-docker-container-uid-gid/ target=_blank rel=noopener>fixuid</a>, но это решение прям &ldquo;так себе&rdquo;. Лучшим путём мне показался проброс локальных <code>USER_ID</code> и его <code>GROUP_ID</code> внутрь контейнера, и <a class=link href=https://gitlab.com/tarampampam/laravel-in-docker/blob/master/docker-compose.yml#L21 target=_blank rel=noopener>запуск процессов с этими значениями</a>. По умолчанию подставляя значения <code>1000:1000</code> (значения по умолчанию для первого локального пользователя) избавился от вызова <code>$(id -u):$(id -g)</code>, а при необходимости - ты всегда их можешь переопределить (<code>$ USER_ID=666 docker-compose up -d</code>) или сунуть в <code>.env</code> файл docker-compose.</p><p>Так же при локальном запуске <code>php-fpm</code> не забудь отключить у него <code>opcache</code> - иначе куча &ldquo;да что за чертовщина!&rdquo; тебе будут обеспечены.</p><p>Для &ldquo;прямого&rdquo; подключения к redis и postgres - прокинул дополнительные порты &ldquo;наружу&rdquo; (<code>16379</code> и <code>15432</code> соответственно), так что проблем с тем, чтоб &ldquo;подключиться да посмотреть что да как там на самом деле&rdquo; не возникает в принципе.</p><p>Контейнер с кодовым именем <code>app</code> держу запущенным (<code>--command keep-alive.sh</code>) с целью удобного доступа к приложению.</p><p>Вот несколько примеров решения &ldquo;бытовых&rdquo; задач с помощью <code>docker-compose</code>:</p><table><thead><tr><th>Операция</th><th>Выполняемая команда</th></tr></thead><tbody><tr><td>Установка <code>compose</code>-пакета</td><td><code>$ docker-compose exec app composer require package/name</code></td></tr><tr><td>Запуск phpunit</td><td><code>$ docker-compose exec app php ./vendor/bin/phpunit --no-coverage</code></td></tr><tr><td>Установка всех node-зависимостей</td><td><code>$ docker-compose run --rm node npm install</code></td></tr><tr><td>Установка node-пакета</td><td><code>$ docker-compose run --rm node npm i package_name</code></td></tr><tr><td>Запуск &ldquo;живой&rdquo; пересборки asset-ов</td><td><code>$ docker-compose run --rm node npm run watch</code></td></tr></tbody></table><p>Все детали запуска ты сможешь найти в файле <strong><a class=link href=https://gitlab.com/tarampampam/laravel-in-docker/blob/master/docker-compose.yml target=_blank rel=noopener>docker-compose.yml</a></strong>.</p><h3 id=цой-make-жив><del>Цой</del> <code>make</code> жив!</h3><p>Набивать одни и те же команды каждый раз становится скучно после второго раза, и так как программисты по своей натуре - существа ленивые, давай займёмся их &ldquo;автоматизацией&rdquo;. Держать набор <code>sh</code>-скриптов - вариант, но не такой привлекательный, как один <code>Makefile</code>, тем более что его применимость в современной разработке сильно недооценена.</p><p>Давай посмотри как выглядит запуск <code>make</code> в корне репозитория:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash><span class=o>[</span>user@host ~/projects/app<span class=o>]</span> $ make

  <span class=nb>help</span>            Show this <span class=nb>help</span>
  app-pull        Application - pull latest Docker image <span class=o>(</span>from remote registry<span class=o>)</span>
  app             Application - build Docker image locally
  app-push        Application - tag and push Docker image into remote registry
  sources-pull    Sources - pull latest Docker image <span class=o>(</span>from remote registry<span class=o>)</span>
  sources         Sources - build Docker image locally
  sources-push    Sources - tag and push Docker image into remote registry
  nginx-pull      Nginx - pull latest Docker image <span class=o>(</span>from remote registry<span class=o>)</span>
  nginx           Nginx - build Docker image locally
  nginx-push      Nginx - tag and push Docker image into remote registry
  pull            Pull all Docker images <span class=o>(</span>from remote registry<span class=o>)</span>
  build           Build all Docker images
  push            Tag and push all Docker images into remote registry
  login           Log in to a remote Docker registry
  clean           Remove images from <span class=nb>local</span> registry
  --------------- ---------------
  up              Start all containers <span class=o>(</span>in background<span class=o>)</span> <span class=k>for</span> development
  down            Stop all started <span class=k>for</span> development containers
  restart         Restart all started <span class=k>for</span> development containers
  shell           Start shell into application container
  install         Install application dependencies into application container
  watch           Start watching assets <span class=k>for</span> changes <span class=o>(</span>node<span class=o>)</span>
  init            Make full application initialization <span class=o>(</span>install, seed, build assets, etc<span class=o>)</span>
  <span class=nb>test</span>            Execute application tests

  Allowed <span class=k>for</span> overriding next properties:

    PULL_TAG - Tag <span class=k>for</span> pulling images before building own
              <span class=o>(</span><span class=s1>&#39;latest&#39;</span> by default<span class=o>)</span>
    PUBLISH_TAGS - Tags list <span class=k>for</span> building and pushing into remote registry
                   <span class=o>(</span>delimiter - single space, <span class=s1>&#39;latest&#39;</span> by default<span class=o>)</span>

  Usage example:
    make <span class=nv>PULL_TAG</span><span class=o>=</span><span class=s1>&#39;v1.2.3&#39;</span> <span class=nv>PUBLISH_TAGS</span><span class=o>=</span><span class=s1>&#39;latest v1.2.3 test-tag&#39;</span> app-push
</code></pre></div><p>Он очень хорош зависимостью целей. Например, для запуска <code>watch</code> (<code>docker-compose run --rm node npm run watch</code>) необходимо что бы приложение было &ldquo;поднято&rdquo; - тебе достаточно указать цель <code>up</code> как зависимую - и можешь не беспокоиться о том, что ты забудешь это сделать перед вызовом <code>watch</code> - <code>make</code> сам всё сделает за тебя. То же касается запуска тестов и статических анализаторов, например, перед коммитом изменений - выполни <code>make test</code> и вся магия произойдет за тебя!</p><p>Стоит ли говорить о том, что для сборки образов, их скачивания, указания <code>--cache-from</code> и всего-всего - уже не стоит беспокоиться?</p><p>Ознакомиться с содержанием <code>Makefile</code> ты можешь по <a class=link href=https://gitlab.com/tarampampam/laravel-in-docker/blob/master/Makefile target=_blank rel=noopener>этой ссылке</a>.</p><h2 id=часть-автоматическая>Часть автоматическая</h2><p>Приступим к финальной части данной статьи - это автоматизация процесса обновления образов в Docker Registry. Хоть в моём примере и используется GitLab CI - перенести идею на другой сервис интеграции, думаю, будет вполне возможно.</p><p>Первым делом определимся и именованием используемых тегов образов:</p><table><thead><tr><th>Имя тега</th><th>Предназначение</th></tr></thead><tbody><tr><td><code>latest</code></td><td>Образы, собранные с ветки <code>master</code>. Состояние кода является самым &ldquo;свежим&rdquo;, но ещё не готовым к тому, что бы попасть в релиз</td></tr><tr><td><code>some-branch-name</code></td><td>Образы, собранные на бранче <code>some-branch-name</code>. Таким образом мы можем на любом окружении &ldquo;раскатать&rdquo; изменения которые были реализованы только в рамках конкретного бранча ещё до их сливания с <code>master</code>-веткой - достаточно &ldquo;вытянуть&rdquo; образы с этим тегом. И - да, изменения могут касаться как кода, так и образов всех сервисов в целом!</td></tr><tr><td><code>vX.X.X</code></td><td>Собственно, релиз приложения (использовать для разворачивания конкретной версии)</td></tr><tr><td><code>stable</code></td><td>Алиас, для тега со самым свежим релизом (использовать для разворачивания самой свежей стабильной версии)</td></tr></tbody></table><p>Для ускорения сборки используется кэширование директорий <code>./src/vendor</code> и <code>./src/node_modules</code> + <code>--cache-from</code> для <code>docker build</code>, и состоит из следующих этапов (<code>stages</code>):</p><table><thead><tr><th>Имя этапа</th><th>Предназначение</th></tr></thead><tbody><tr><td><code>prepare</code></td><td>Подготовительный этап - сборка образов всех сервисов <strong>кроме</strong> образа с исходниками</td></tr><tr><td><code>test</code></td><td>Тестирование приложения (запуск <code>phpunit</code>, статических анализаторов кода) используя образы, <strong>собранные на этапе prepare</strong></td></tr><tr><td><code>build</code></td><td>Установка всех <code>composer</code> зависимостей (<code>--no-dev</code>), сборка <code>assets</code> силами <code>webpack</code>, и сборка образа с исходниками <strong>включая полученные артефакты</strong> (<code>vendor/*</code>, <code>app.js</code>, <code>app.css</code>)</td></tr></tbody></table><p><figure><a href=https://hsto.org/webt/fl/vp/mv/flvpmvfakkf6opnry-ti5he5n00.png><img src=https://hsto.org/webt/fl/vp/mv/flvpmvfakkf6opnry-ti5he5n00.png loading=lazy alt="pipelines screenshot"></a><figcaption>pipelines screenshot</figcaption></figure></p><blockquote><p>Сборка на <code>master</code>-ветке, производящая <code>push</code> с тегами <code>latest</code> и <code>master</code></p></blockquote><p>В среднем, все этапы сборки занимают <strong>4 минуты</strong>, что довольно хороший результат (параллельное выполнение задач - наше всё).</p><p>Ознакомиться с содержанием конфигурации (<strong><code>.gitlab-ci.yml</code></strong>) сборщика можешь ознакомиться по <a class=link href=https://gitlab.com/tarampampam/laravel-in-docker/blob/master/.gitlab-ci.yml target=_blank rel=noopener>этой ссылке</a>.</p><h2 id=вместо-заключения>Вместо заключения</h2><p>Как видишь - организовать работу с php-приложением (на примере <code>Laravel</code>) используя Docker не так то и сложно. В качестве теста можешь форкнуть <a class=link href=https://gitlab.com/tarampampam/laravel-in-docker target=_blank rel=noopener>репозиторий</a>, и заменив все вхождения <code>tarampampam/laravel-in-docker</code> на свои - попробовать всё &ldquo;в живую&rdquo; самостоятельно.</p><p>Для локального запуска - выполни всего 2 команды:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ git clone https://gitlab.com/tarampampam/laravel-in-docker.git ./laravel-in-docker <span class=o>&amp;&amp;</span> <span class=nb>cd</span> <span class=nv>$_</span>
$ make init
</code></pre></div><p>После чего открой <code>http://127.0.0.1:9999</code> в своём любимом браузере.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/php/>php</a>
<a href=/tags/devops/>devops</a>
<a href=/tags/linux/>linux</a>
<a href=/tags/docker/>docker</a></section><div style=display:flex;justify-content:space-between;margin-top:1em><div><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>WTFPL</span></section></div><div style=margin-left:auto><section style=height:100%><a href=https://github.com/hook-sh/blog/edit/master/content/post/laravel-in-docker/index.md style=font-size:.7em;color:var(--card-text-color-tertiary)>Редиктировать</a></section></div></div></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Может быть интересно</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/compose-deploy/><div class=article-image><img src=/compose-deploy/cover.31826785bbf29e0ec311943642776de7_hu65abd86000f73060febdb2dd524fa8aa_21589_250x150_fill_box_smart1_2.png width=250 height=150 loading=lazy data-key=compose-deploy data-hash="md5-MYJnhbvyng7DEZQ2Qndt5w=="></div><div class=article-details><h2 class=article-title>Деплой на Docker Swarm</h2></div></a></article><article class=has-image><a href=/iptables-for-docker-swarm/><div class=article-image><img src=/iptables-for-docker-swarm/cover.46786305ea94fea9001f78310af2161c_huca17b364cb926e2346fafd474740dcec_161710_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy data-key=iptables-for-docker-swarm data-hash="md5-RnhjBeqU/qkAH3gxCvIWHA=="></div><div class=article-details><h2 class=article-title>Настройка iptables для swarm кластера</h2></div></a></article><article class=has-image><a href=/compile-and-config-msmtp/><div class=article-image><img src=/compile-and-config-msmtp/cover.74e5f5752c378bc5c249233e9c0f8284_hub577c79af8463c924351e5a1445741f0_93501_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy data-key=compile-and-config-msmtp data-hash="md5-dOX1dSw3i8XCSSM+nA+ChA=="></div><div class=article-details><h2 class=article-title>Собираем и настраиваем msmtp</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=hook-sh/blog issue-term=pathname crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>function setUtterancesTheme(b){let a=document.querySelector('.utterances iframe');a&&a.contentWindow.postMessage({type:'set-theme',theme:`github-${b}`},'https://utteranc.es')}addEventListener('message',a=>{if(a.origin!=='https://utteranc.es')return;setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener('onColorSchemeChange',a=>{setUtterancesTheme(a.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2014 -
2021 blog [dot] hook</section><section class=powerby>Make love, not war<br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Содержание</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#часть-теоретическая>Часть теоретическая</a></li><li><a href=#часть-практическая>Часть практическая</a><ol><li><a href=#цой-make-жив>Цой <code>make</code> жив!</a></li></ol></li><li><a href=#часть-автоматическая>Часть автоматическая</a></li><li><a href=#вместо-заключения>Вместо заключения</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script><script data-no-instant>(function(){const a=document.querySelectorAll('.outdated-post'),b=new Date;for(let c=0,f=a.length;c<f;c++){const d=a[c],e=new Date(d.getAttribute('data-posted-at'));if(!isNaN(e.valueOf())&&e.getFullYear()>1){const a=Math.abs(b.getTime()-e.getTime()),c=Math.ceil(a/(1e3*3600*24));c>=547&&(d.style.display='block',d.style.visibility='visible')}}})()</script></body></html>
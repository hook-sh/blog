---
title: Шаблонизация в CLI может быть простой
slug: mustpl
#description: Mustpl
date: 2022-08-26T13:19:03Z
expirydate: 2028-02-27T13:19:03Z
#draft: true
toc: false
image: cover.jpg
categories: [adm, dev, software]
tags: [c, templating]
---

Однажды я был маленьким, и задавался вопросом - вот если Unix way это (упрощенно) небольшие, довольно простые утилиты и библиотеки, которые делают одну вещь, но делают её хорошо _(Peter H. Salus: "...that do one thing and do it well")_, то... Где тогда утилита, которая занимается шаблонизацией и не хватает звёзд с неба? Вот есть у тебя некоторый шаблон, и есть некоторые данные, которые ты имеешь желание в этот шаблон подставить. Брать для этого Jinja2? Писать что-то своё используя `sed` + `awk`? Или тащить %tool_name% на несколько мегабайт ради столь тривиальной задачи?

Спустя некоторое время, вновь столкнувшись с подобной задачей, и поняв что попытка найти что-то подходящее вновь претерпела фиаско, было принято волевое решение - да-да, написать свой ~~прекрасный проект~~ ~~велосипед~~ шаблонизатор для использования в CLI. Ограничения были выбраны следующие:

- Статическая линковка - один бинарный файл без каких-либо зависимостей (он мне понадобится в docker scratch)
- Итоговый размер должен быть минимально-возможным (постараться уместиться в 100Кб без upx)

<!--more-->

На чем писать, если хочется ~~боли~~ компактного и быстрого - естественно, берём C. Какой шаблонизатор использовать, если хочется минимализма? Под такую задачу хорошо подойдет [mustache](https://mustache.github.io/). И вот, спустя некоторое время появляется [**mustpl**](https://github.com/tarampampam/mustpl).

## Как его использовать?

Предельно просто - дай на вход путь до файла с шаблоном, файла с данными для этого шаблона (или передай их в виде JSON-строки используя флаг `-d`), и опционально передай нужные переменные окружения. Представим, что у нас есть следующий шаблон (`nginx.tpl`):

```jinja
server {
  listen      8080;
  server_name{{#names}} {{ . }}{{/names}};

  location / {
    root  /var/www/data;
    index index.html index.htm;
  }
}
```

Для генерации результирующего файла достаточно выполнить:

```shell
$ SERVER_NAME_1=example.com mustpl -d '{"names": ["${SERVER_NAME_1:-fallback.com}", "google.com"]}' ./nginx.tpl
server {
  listen      8080;
  server_name example.com google.com;

  location / {
    root  /var/www/data;
    index index.html index.htm;
  }
}
```

Поддерживаются и **циклы**, и **условия**, и подключение других файлов-шаблонов, и escaping значений - все детали и нужные ссылки сможешь найти в [readme файле](https://github.com/tarampampam/mustpl#readme) репозитория.

## Но почему ты просто не взял %tool_name%?

Кроме того, что целью был минимальный размер итогового бинарного файла, отсутствие зависимостей и скорость работы, есть ещё как минимум одна очень важная причина - это комфортное использование в docker, а именно - навык **парсить переменные окружения** (aka `envsubst`) и возможность использования в качестве **точки входа** (entrypoint).

Скорее всего ты знаешь, что основной процесс, запускаемый в контейнере - должен иметь PID равный 1 (в неймспейсе контейнера). Нужно это для того, чтоб демон докера мог корректно общаться (отправляя сигналы) с приложением, что у тебя в этом самом контейнере крутится.

Именно это является причиной почему, как правило, в entrypoint-скриптах используется конструкция вида:

```bash
#!/bin/sh
set -e

if [ -n "$MY_OPTION" ]; then # если переменная окружения имеется
  sed -i "s~foo~bar ${MY_OPTION}~" /etc/app.cfg # то подставляем её в конфиг
fi;

exec "$@" # <-- а вот это самое интересное
```

Которая в паре со следующими `entrypoint`/`cmd` в dockerfile:

```dockerfile
ENTRYPOINT ["/docker-entrypoint.sh"]

CMD ["/bin/app", "--another", "flags"]
```

Работает следующим образом:

- Запускается процесс `sh` c PID 1, который выполняет скрипт `/docker-entrypoint.sh`
- Скрипт выполняет все необходимые модификации конфига некоторого приложения (если это необходимо), и вызывает `exec` (который **заменяет** текущий процесс новым, не изменяя при этом свой PID, детали в `man exec`)
- Запускается процесс `app` и его PID становится 1

И мне очень хотелось иметь возможность отказаться от этих самых entrypoint скриптов, так как они тянут массу зависимостей (а distroless же наше всё), да и писать их утомляет очень быстро. И было принято решение научить mustpl выполнять этот самый `exec` самостоятельно. Т.е. чтоб алгоритм запуска был следующий:

- Запускается mustpl с PID 1, который читая файл шаблона и данные для него генерирует необходимый конфиг для некоторого приложения
- Выполняет `exec`, запуская нужное приложение, не меняя PID (т.е. оставляя его равным 1)

Как это выглядит? Тоже очень просто, давай создадим файлы с шаблоном (`template.ini`):

```ini
[config]
value = {{ my_option }}
```

Данными для него (`data.json`):

```json
{
  "my_option": "${MY_OPTION:-default value}"
}
```

И следующий `Dockerfile`:

```dockerfile
FROM alpine:latest

COPY --from=ghcr.io/tarampampam/mustpl /bin/mustpl /bin/mustpl

COPY ./data.json /data.json
COPY ./template.ini /template.ini

ENTRYPOINT ["mustpl", "-f", "/data.json", "-o", "/rendered.txt", "/template.ini", "--"]

CMD ["sleep", "infinity"]
```

Теперь давай соберем образ и запустим его:

```bash
$ docker build --tag test:local .
$ docker run --rm --name mustpl_example -e "MY_OPTION=foobar" test:local
```

В этот момент происходит следующее:

- Запускается `mustpl` (т.к. он указан в `entrypoint`), который читает файлы `/data.json` и `/template.ini`
- В данных шаблона значение для `my_option` заменяется на `foobar`, так как переменная окружения `MY_OPTION` установлена (мы же указали `-e "MY_OPTION=foobar"`; в противном случае там бы оказалось значение `default value`)
- Шаблон рендерится, и сохраняется в `/rendered.txt`
- `mustpl` сохраняет все аргументы, что были указаны после пути до файла с шаблоном (это единственный обязательный параметр), трактуя их как имя и параметры запускаемого приложения (в нашем случае это `sleep` с аргументом `infinity`), двойное тире `--` необходимо чтоб любые последующие флаги не парсились `mustpl` а читались "как есть"
- Запускается процесс `sleep` и PID равный 1 сохраняется уже за ним, а mustpl просто завершает свою работу (фактически происходит замена образа, но это сейчас не так важно)

Давай проверим, так ли это на самом деле (выполним в отдельном терминале):

```bash
$ docker exec mustpl_example ps aux
PID   USER     TIME  COMMAND
    1 root      0:00 sleep infinity # <-- PID как видим на самом деле == 1
    7 root      0:00 ps aux

$ docker exec mustpl_example cat /rendered.txt
[config]
value = foobar # <-- а вот и наше значение!

$ docker kill mustpl_example
```

## Вместо заключения

Область применения этой утилиты, естественно, довольно ограничена. Да, она не умеет Jinja-like модификаторов, кастомных функций (хотя, они описаны в спецификации mustache), да много ещё чего. Но она умеет просто шаблонизировать, и если сделает кому-то жизнь чуточку проще - я буду счастлив. Инструкции по установке, готовые бинакрники, документация - всё это найдете в [репозитории этой тулы](https://github.com/tarampampam/mustpl). Отдельное спасибо [@jetexe](https://github.com/jetexe) и [@alexndr-novikov](https://github.com/alexndr-novikov) за ревью и режим "желтой уточки".
